<!DOCTYPE html>
<html>

    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Joystick Gremlin</title>

    <link rel="canonical" href="https://whitemagic.github.io/JoystickGremlinhttps://whitemagic.github.io/JoystickGremlin/user_plugins/">

    <!-- Code highlighting CSS -->
    <link rel="stylesheet" href="https://whitemagic.github.io/JoystickGremlin/css/github.css">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">

    <!-- Javascript -->
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js" integrity="sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js" integrity="sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ" crossorigin="anonymous"></script>

    <!-- MathJax -->
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <!-- Raleway font -->
    <!--<link href='https://fonts.googleapis.com/css?family=Raleway' rel='stylesheet' type='text/css'>-->

    <!-- Custom CSS overrides -->
    <link rel="stylesheet" href="https://whitemagic.github.io/JoystickGremlin/css/override.css">

    <!-- Atom feed -->
    <link href="https://whitemagic.github.io/JoystickGremlin/feed.xml" type="application/rss+xml" rel="alternate" title="Joystick Gremlin - Changelog" />
</head>


    <body>

        <nav class="navbar navbar-expand-lg navbar-dark bg-dark">

            <a class="navbar-brand" href="https://whitemagic.github.io/JoystickGremlin">
                <img src="https://whitemagic.github.io/JoystickGremlin/images/icon.png">
            </a>

            <div class="collapse navbar-collapse" id="navbar-collapse">
                <ul class="navbar-nav mr-auto">
                    <!-- Home -->
                    <li class="nav-item"><a class="nav-link" href="https://whitemagic.github.io/JoystickGremlin/">Home</a></li>

                    <!-- Download -->
                    <li class="nav-item"><a class="nav-link" href="https://whitemagic.github.io/JoystickGremlin/download/">Download</a></li>

                    <!-- User Plugins -->
                    <li class="nav-item"><a class="nav-link" href="https://whitemagic.github.io/JoystickGremlin/user_plugins_code/">User Plugins</a></li>

                    <!-- Manual entries -->
                    <li class="nav-item dropdown active">
                        <a href="#" id="navbarDropdown" class="nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Manual<span class="caret"></span></a>

                        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                            <a class="dropdown-item" href="https://whitemagic.github.io/JoystickGremlin/overview/">Overview</a>
                            <a class="dropdown-item" href="https://whitemagic.github.io/JoystickGremlin/quickstart/">Quickstart</a>
                            <a class="dropdown-item" href="https://whitemagic.github.io/JoystickGremlin/interface/">Interface</a>
                            <a class="dropdown-item active" href="https://whitemagic.github.io/JoystickGremlin/user_plugins/">User Plugins</a>
                            <a class="dropdown-item" href="https://whitemagic.github.io/JoystickGremlin/technical_design/">Technical Design</a>
                            <a class="dropdown-item" href="https://whitemagic.github.io/JoystickGremlin/examples/">Examples</a>
                            <a class="dropdown-item" href="https://whitemagic.github.io/JoystickGremlin/faq/">FAQ</a>
                            <a class="dropdown-item" href="https://whitemagic.github.io/JoystickGremlin/changelog/">Changelog</a>
                        </div>
                    </li>
                </ul>

                <ul class="navbar-nav navbar-right">
                    <li class="nav-item"><a class="nav-link" href="https://github.com/WhiteMagic/JoystickGremlin">Github</a></li>
                </ul>
            </div>
        </nav>

        <div class="container">
            <div class="row mt-4">
                <div class="col-md-2"></div>
                <div class="col-md-8">
                    <h1><a name="4">4. User Plugins</a></h1>

<p class="text-justify">
    While common configuration tasks can be performed directly via the
    UI, more advanced and specialised configurations may either only be
    possible or much simpler by using a user plugin. Each plugin is a
    simple Python script which defines the variables a user can
    configure via the UI and the functions (callbacks) triggered in
    reaction to (configured) inputs being
    used. Since the functions are written in Python there is no limit as
    to what can be expressed. The following section assumes some basic
    familiarity with Python.
</p>

<p class="text-justify">
    We start with a general overview of the
    layout of a user plugin in <a href="#4_1">Section 4.1</a> which is
    followed by an quick overview of the API in <a href="#4_2">Section
    4.2</a> followed by the description of the decorator based callback
    system in <a href="#4_3">Section 4.3</a> with periodic function
    callbacks described in <a href="#4_4">Section 4.4</a>. Some words on how
    to debug user plugins is provided in <a href="#4_5">Section 4.5</a>.
    Finally, <a href="#4_6">Section 4.6</a> provides a few practical
    examples.
</p>


<h2><a name="4_1">4.1 Principles &amp; Layout of User Plugin</a></h2>

<p class="text-justify">
    Joystick Gremlin uses callbacks, i.e. functions that are executed in
    reaction to user inputs such as key presses or axis motion. These
    callbacks have access to some convenience functions which allow
    accessing and controlling commonly used parts of the system, such as
    setting the value of vJoy devices or retrieving keyboard and
    joystick states. Combining these readily available functions with
    custom code allows the implementation of varied functionality.
</p>

<p class="text-justify">
    In order to make user plugins reusable and convenient to use a set
    of classes exist which allow setting them via the UI, thus allowing
    a user to customize the plugins directly from the UI. These variable
    classes allow configuration of commonly used types such as modes,
    inputs, as well as numerical values.
</p>

<p class="text-justify">
    The general structure of a callback is as follows:
<figure class="highlight"><pre><code class="language-python3" data-lang="python3">@decorator_function(&lt;input name&gt;)
def callback_function(event, &lt;optional parameter list&gt;):
    &lt;callback implementation&gt;</code></pre></figure>
</p>

<p class="text-justify">
    The <code>event</code> parameter contains information about the
    event that triggered the execution of the function. Each event is of
    type <code>gremlin.event_handler.Event</code> and contains the
    following data:
</p>

<div class="card border-dark mb-3">
    <div class="card-header">
        <h5 class="class-title">Event</h5>
    </div>
    <div class="card-body pb-0">
        <dl class="row">
            <dt class="col-md-4"><code>event_type</code></dt>
            <dd class="col-md-8">The type of the event this represents.</dd>

            <dt class="col-md-4"><code>identifier</code></dt>
            <dd class="col-md-8">The identifier of the event source.</dd>

            <dt class="col-md-4"><code>device_guid</code></dt>
            <dd class="col-md-8">Unique device ID associated with the
            device that created the event.</dd>

            <dt class="col-md-4"><code>is_pressed</code></dt>
            <dd class="col-md-8">If the event represents a button or key the value is True for pressed and False for released state.</dd>

            <dt class="col-md-4"><code>value</code></dt>
            <dd class="col-md-8">Value of an axis or hat. In case of an axis the
                value is in the range \(\left[-1, 1\right]\)
                and in the case of a hat a tuple (x direction, y direction) is
                used. This field's value is only valid for joystick axes and
                hats.</dd>

            <dt class="col-md-4"><code>raw_value</code></dt>
            <dd class="col-md-8">The raw axis value, this field is only valid for joystick
                axes.</dd>
            </dl>
    </div>
</div>

<p class="text-justify">
    From this list the only values that are typically of interest are
    the <code>is_pressed</code> and <code>value</code> entries depending
    on the input type.
</p>


<h2><a name="4_2">4.2 Device Access API</a></h2>

<p class="text-justify">
    The following describes the API of the optional variables exposed
    via the decorator plugin framework. The plugins provide access to
    commonly used information by simply adding a properly named
    parameter to the callback function.
</p>
<p class="text-justify">
    These parameters must be listed after the event parameter in the
    case of user input callbacks.
</p>



<h3>vJoy</h3>

<p class="text-justify">
    Any decorated function that has a parameter named <code>vjoy</code>
    in its parameter list will have access to all vJoy devices.
    Accessing a specific <code>VJoy</code> instance is done by indexing
    the <code>vjoy</code> object. This object then allows setting the
    state of inputs by indexing the member variables <code>axis</code>,
    <code>button</code>, and <code>hat</code>. Indices of buttons and
    hats start at 1. For axes the indices correspond to the axis index
    as defined by the device. The following demonstrates typical usage:
</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3"># Access the first vJoy device and press the third button
vjoy[1].button(3).is_pressed = True

# Access the second vJoy device and move the Y axis to -0.25
vjoy[2].axis(AxisName.Y).value = -0.25
# or equivalently
vjoy[2].axis(2).value = -0.25

# Access the first vJoy device and move the first hat to
# the top right position
vjoy[1].hat(1).direction = (1, 1)</code></pre></figure>


<h3>Joystick State</h3>

<p class="text-justify">
    Any decorated function that has a parameter named <code>joy</code>
    in its parameter list will have access to all joystick devices via
    that variable.
</p>


<p class="text-justify">
    <b>Accessing a specific joystick</b></br>
    In order to access a specific joystick its system id needs to be
    known. Using the device's system id as index the joystick can be
    accessed by:
    <figure class="highlight"><pre><code class="language-python3" data-lang="python3">joystick_device = joy[device_guid]</code></pre></figure>
</p>


<p class="text-justify">
    <b>Reading axis value</b></br>
    To read the current value of a joystick axis both the index of the
    axis as well as the system id of the joystick, starting with 1, are
    needed, with these the axis value is obtained as:
    <figure class="highlight"><pre><code class="language-python3" data-lang="python3">axis_value = joy[device_guid].axis(axis_index).value</code></pre></figure>
</p>

<p class="text-justify">
    <b>Reading button state</b></br>
    To read the current state of a button both the joystick's system id
    as well as index of the button, starting at 1, are needed. The
    following then reads the button state:
    <figure class="highlight"><pre><code class="language-python3" data-lang="python3">state = joy[device_guid].button(button_id).is_pressed</code></pre></figure>
</p>


<p class="text-justify">
    <b>Reading hat position</b></br>
    To read the current position of a hat both the joystick's system id
    and hat index, starting at 1, are needed. The position of the hat is
    reported as a \((x, y)\) tuple \(x, y
    \in \left\{-1, 0, 1\right\}\). A \(x\) value of 1 is right
    and -1 left while a value of 1 for \(y\) means up and -1 down. A
    value of \(0\) represents a centred position. The value is read as follows:
    <figure class="highlight"><pre><code class="language-python3" data-lang="python3">position = joy[device_guid].hat(hat_id).direction</code></pre></figure>
</p>


<h3>Keyboard State</h3>

<p class="text-justify">
    Any decorated function that has a parameter named
    <code>keyboard</code> in its parameter list will have access to the
    state of all keyboard keys.
</p>

<p class="text-justify">
    <b>Reading key state</b></br>
    To read the key state the string representation of the key or the
    <code>gremlin.macro.Key</code> instance corresponding to the key is
    needed. Both can be found in the <code>gremlin.macro</code> module.
    Reading the state is then done as follows:
    <figure class="highlight"><pre><code class="language-python3" data-lang="python3">is_pressed = keyboard.is_pressed(key)</code></pre></figure>
</p>


<h2><a name="4_3">4.3 User Input Callback Generation</a></h2>

<p class="text-justify">
    Callbacks reacting to user inputs are created by decorating functions using
    specific decorators. Here are two useful links if you're not familiar with
    decorators, <a href="https://www.python.org/dev/peps/pep-0318/">official
    PEP</a> and an <a href="https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators/1594484#1594484">exhaustive
    StackOverflow answer</a> There are two types of decorators,
    one for joysticks and one for the keyboard. Joystick decorators are created
    for specific devices using the
    <code>gremlin.input_devices.JoystickDecorator</code> class as follows:
<figure class="highlight"><pre><code class="language-python3" data-lang="python3">joystick_decorator = gremlin.input_devices.JoystickDecorator(
    &quot;&lt;device name&gt;&quot;,
    &quot;{&lt;device guid&gt;}&quot;,
    &quot;&lt;mode&gt;&quot;
)</code></pre></figure>
</p>

<p class="text-justify">
    The value of <code>device_guid</code> is the unique dentifier of the
    device. An object created in this way has three decorators
    customised for the given joystick and mode, which can be used as
    follows:
<figure class="highlight"><pre><code class="language-python3" data-lang="python3">@joystick_decorator.axis(1)
def axis_callback(event):
    pass

@joystick_decorator.button(4)
def button_callback(event):
    pass

@joytick_decorator.hat(2)
def hat_callback(event):
    pass</code></pre></figure>
</p>

<p class="text-justify">
    The keyboard decorator can be used directly as follows:
<figure class="highlight"><pre><code class="language-python3" data-lang="python3">@gremlin.input_devices.keyboard(&lt;key name&gt;, &lt;mode&gt;)
def keyboard_callback(event):
    pass</code></pre></figure>
</p>

<p class="text-justify">
    Where <code>key name</code> can be either a string representation
    of the key's name as or an instance of <code>gremlin.marco.Key</code> which
    are both defined in the <code>gremlin.macro</code> module.
</p>

<p class="text-justify">
    The <code>event</code> parameter of the decorated function is always
    required and contains the state of the input that triggered the callback,
    the contents of the variable are described in <a href="#4_1">Section
    4.1</a>.
</p>


<h2><a name="4_4">4.4 Periodic Function Callbacks</a></h2>

<p class="text-justify">
    In some situations a function needs to be executed at regular
    intervals. This is facilitated by a decorator that ensures that the
    function is run at a specified interval while Joystick Gremlin is
    active.
</p>

<p class="text-justify">
    The decorator takes a single argument that indicates the interval, i.e. the
    duration, between executions of the function in seconds. The callback
    function can use the same plugin system as the user input callbacks to gain
    access to device information, e.g. <code>vjoy</code>, <code>joy</code>, and
    <code>keyboard</code>. A generic example of periodic function callback is
    shown below.
</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">@gremlin.input_devices.periodic(&lt;seconds&gt;)
def periodic_function():
    pass</code></pre></figure>
</p>



<h2><a name="4_5">4.5 Configurable Variables</a></h2>

<p class="text-justify">
    In order to allow user plugins to be configured by users via the UI
    several types of variable classes exist, that are automatically
    extracted from the plugin and presented to the user for
    customization.
</p>

<p class="text-justify">
    The following variable types exist and will be explained in more
    detail below.
    <dl class="row">
        <dt class="col-md-4"><code>IntegerVariable</code></dt>
        <dd class="col-md-8">Holds a single integer value.</dd>
        

        <dt class="col-md-4"><code>FloatVariable</code></dt>
        <dd class="col-md-8">Holds a single float value.</dd>

        <dt class="col-md-4"><code>BoolVariable</code></dt>
        <dd class="col-md-8">Holds a single boolean value.</dd>

        <dt class="col-md-4"><code>StringVariable</code></dt>
        <dd class="col-md-8">Holds an arbitrary length string.</dd>

        <dt class="col-md-4"><code>ModeVariable</code></dt>
        <dd class="col-md-8">Holds the value of one of the modes
        existing in the profile.</dd>

        <dt class="col-md-4"><code>VirtualInputVariable</code></dt>
        <dd class="col-md-8">Holds one vJoy selection.</dd>

        <dt class="col-md-4"><code>PhysicalInputVariable</code></dt>
        <dd class="col-md-8">Holds one physical device input.</dd>
    </dl>
</p>


<h3>IntegerVariable</h3>

<p class="text-justify">
    This variable can hold any single integer value and presents the
    user with a field which allows entering of values. The variable also
    allows the specification of limits for valid values.
</p>

<div class="card border-dark mb-3">
    <div class="card-header">
        <h5
            class="class-title">gremlin.user_plugin.IntegerVariable.__init__</h5>
    </div>
    <div class="card-body pb-0">
        <dl class="row">
            <dt class="col-md-3"><code>label</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Label shown for the UI element.</dd>

            <dt class="col-md-3"><code>description</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Text describing the purpose of the
            variable.</dd>

            <dt class="col-md-3"><code>initial_value</code></dt>
            <dd class="col-md-2">optional</dd>
            <dd class="col-md-7">Default value to use for this variable.</dd>
            
            <dt class="col-md-3"><code>min_value</code></dt>
            <dd class="col-md-2">optional</dd>
            <dd class="col-md-7">Minimum value this variable can take
            on.</dd>

            <dt class="col-md-3"><code>max_value</code></dt>
            <dd class="col-md-2">optional</dd>
            <dd class="col-md-7">Maximum value this variable can take
            on.</dd>
        </dl>
    </div>
</div>


<h3>FloatVariable</h3>

<p class="text-justify">
    This variable can hold any single floating point value and presents
    the user with a field which allows entering of values. The variable
    also allows the specification of limits for valid values.
</p>

<div class="card border-dark mb-3">
    <div class="card-header">
        <h5
            class="class-title">gremlin.user_plugin.FloatVariable.__init__</h5>
    </div>
    <div class="card-body pb-0">
        <dl class="row">
            <dt class="col-md-3"><code>label</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Label shown for the UI element.</dd>

            <dt class="col-md-3"><code>description</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Text describing the purpose of the
            variable.</dd>

            <dt class="col-md-3"><code>initial_value</code></dt>
            <dd class="col-md-2">optional</dd>
            <dd class="col-md-7">Default value to use for this variable.</dd>
            
            <dt class="col-md-3"><code>min_value</code></dt>
            <dd class="col-md-2">optional</dd>
            <dd class="col-md-7">Minimum value this variable can take
            on.</dd>

            <dt class="col-md-3"><code>max_value</code></dt>
            <dd class="col-md-2">optional</dd>
            <dd class="col-md-7">Maximum value this variable can take
            on.</dd>
        </dl>
    </div>
</div>


<h3>BoolVariable</h3>

<p class="text-justify">
    This variable can hold any single boolean value and presents
    the user with a checkbox. This can be used to turn features of a
    plugin on and off.
</p>

<div class="card border-dark mb-3">
    <div class="card-header">
        <h5
            class="class-title">gremlin.user_plugin.BoolVariable.__init__</h5>
    </div>
    <div class="card-body pb-0">
        <dl class="row">
            <dt class="col-md-3"><code>label</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Label shown for the UI element.</dd>

            <dt class="col-md-3"><code>description</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Text describing the purpose of the
            variable.</dd>

            <dt class="col-md-3"><code>initial_value</code></dt>
            <dd class="col-md-2">optional</dd>
            <dd class="col-md-7">Default value to use for this variable.</dd>
        </dl>
    </div>
</div>


<h3>StringVariable</h3>

<p class="text-justify">
    This variable can hold any string and presents the user with a text
    input field.
</p>

<div class="card border-dark mb-3">
    <div class="card-header">
        <h5
            class="class-title">gremlin.user_plugin.StringVariable.__init__</h5>
    </div>
    <div class="card-body pb-0">
        <dl class="row">
            <dt class="col-md-3"><code>label</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Label shown for the UI element.</dd>

            <dt class="col-md-3"><code>description</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Text describing the purpose of the
            variable.</dd>

            <dt class="col-md-3"><code>initial_value</code></dt>
            <dd class="col-md-2">optional</dd>
            <dd class="col-md-7">Default value to use for this variable.</dd>
        </dl>
    </div>
</div>


<h3>ModeVariable</h3>

<p class="text-justify">
    This variable holds the name of one mode present in this profile.
    The user is presented with a dropdown list containing all modes that
    exist.
</p>

<div class="card border-dark mb-3">
    <div class="card-header">
        <h5
            class="class-title">gremlin.user_plugin.ModeVariable.__init__</h5>
    </div>
    <div class="card-body pb-0">
        <dl class="row">
            <dt class="col-md-3"><code>label</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Label shown for the UI element.</dd>

            <dt class="col-md-3"><code>description</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Text describing the purpose of the
            variable.</dd>
        </dl>
    </div>
</div>


<h3>VirtualInputariable</h3>

<p class="text-justify">
    This variable holds one specific vJoy input selection. The user is
    presented with the typical vJoy dropdown boxes.
</p>

<div class="card border-dark mb-3">
    <div class="card-header">
        <h5
            class="class-title">gremlin.user_plugin.VirtualInputVariable.__init__</h5>
    </div>
    <div class="card-body pb-0">
        <dl class="row">
            <dt class="col-md-3"><code>label</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Label shown for the UI element.</dd>

            <dt class="col-md-3"><code>description</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Text describing the purpose of the
            variable.</dd>

            <dt class="col-md-3"><code>valid_types</code></dt>
            <dd class="col-md-2">optional</dd>
            <dd class="col-md-7">List of valied
            <code>gremlin.common.InputType</code> values</dd>
        </dl>
    </div>
</div>


<h3>PhysicalInputariable</h3>

<p class="text-justify">
    This variable holds one specific physical input device selection.
    The user can press a button at which point Gremlin will record the
    physical input being activated next.
</p>

<div class="card border-dark mb-3">
    <div class="card-header">
        <h5
            class="class-title">gremlin.user_plugin.PhysicalInputVariable.__init__</h5>
    </div>
    <div class="card-body pb-0">
        <dl class="row">
            <dt class="col-md-3"><code>label</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Label shown for the UI element.</dd>

            <dt class="col-md-3"><code>description</code></dt>
            <dd class="col-md-2">mandatory</dd>
            <dd class="col-md-7">Text describing the purpose of the
            variable.</dd>

            <dt class="col-md-3"><code>valid_types</code></dt>
            <dd class="col-md-2">optional</dd>
            <dd class="col-md-7">List of valied
            <code>gremlin.common.InputType</code> values</dd>
        </dl>
    </div>
</div>


<h3>Example</h3>

<p class="text-justify">
    This example plugin lets a user specify four physical joystick
    buttons and map them to a single virtual hat output.
</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">import gremlin
from gremlin.user_plugin import *


mode = ModeVariable(
        &quot;Mode&quot;,
        &quot;The mode to use for this mapping&quot;
)
vjoy_hat = VirtualInputVariable(
        &quot;Output Hat&quot;,
        &quot;vJoy hat to use as the output&quot;,
        [gremlin.common.InputType.JoystickHat]
)
btn_1 = PhysicalInputVariable(
        &quot;Button Up&quot;,
        &quot;Button which will be mapped to the up direction of the hat.&quot;,
        [gremlin.common.InputType.JoystickButton]
)
btn_2 = PhysicalInputVariable(
        &quot;Button Right&quot;,
        &quot;Button which will be mapped to the right direction of the hat.&quot;,
        [gremlin.common.InputType.JoystickButton]
)
btn_3 = PhysicalInputVariable(
        &quot;Button Down&quot;,
        &quot;Button which will be mapped to the down direction of the hat.&quot;,
        [gremlin.common.InputType.JoystickButton]
)
btn_4 = PhysicalInputVariable(
        &quot;Button Left&quot;,
        &quot;Button which will be mapped to the left direction of the hat.&quot;,
        [gremlin.common.InputType.JoystickButton]
)

state = [0, 0]

decorator_1 = btn_1.create_decorator(mode.value)
decorator_2 = btn_2.create_decorator(mode.value)
decorator_3 = btn_3.create_decorator(mode.value)
decorator_4 = btn_4.create_decorator(mode.value)


def set_state(vjoy):
    device = vjoy[vjoy_hat.value[&quot;device_id&quot;]]
    device.hat(vjoy_hat.value[&quot;input_id&quot;]).direction  = tuple(state)


@decorator_1.button(btn_1.input_id)
def button_1(event, vjoy):
    global state
    state[1] = 1 if event.is_pressed else 0
    set_state(vjoy)


@decorator_2.button(btn_2.input_id)
def button_2(event, vjoy):
    global state
    state[0] = 1 if event.is_pressed else 0
    set_state(vjoy)


@decorator_3.button(btn_3.input_id)
def button_3(event, vjoy):
    global state
    state[1] = -1 if event.is_pressed else 0
    set_state(vjoy)


@decorator_4.button(btn_4.input_id)
def button_4(event, vjoy):
    global state
    state[0] = -1 if event.is_pressed else 0
    set_state(vjoy)</code></pre></figure>



<h2><a name="4_6">4.6 Debugging</a></h2>

<p class="text-justify">
    To facilitate the debugging of custom modules without setting up the
    source code of Joystick Gremlin in an IDE the logging function
    <code>gremlin.util.log()</code> can be used. This stores the
    provided text to the user log file which can be viewed directly in
    Joystick Gremlin via the <em>Tools -> Log display</em> option.
</p>

<p class="text-justify">
    For more detailed debugging Joystick Gremlin needs to be run from within an
    IDE by getting the development environment setup. While this provides the
    best debugging experience it also involves the most work, thus for simple
    tasks the logging approach may be preferable.
</p>


<h2><a name="4_7">4.7 Examples</a></h2>

<p class="text-justify">
    In the following a few examples of custom modules are shown. They
    provide an illustration of some of the things that can be achieved
    thanks to the combination of Joystick Gremlin provided functions and
    custom Python code.
</p>


<h3>Keyboard Controlled Throttle</h3>

<p class="text-justify">
    This script allows the user to control an analogue throttle in 1/3rd
    increments using the <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, and
    <kbd>4</kbd> number keys.
</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">import gremlin
from vjoy.vjoy import AxisName

def set_throttle(vjoy, value):
    vjoy[1].axis(AxisName.Z).value = value

@gremlin.input_devices.keyboard(&quot;1&quot;, &quot;Global&quot;)
def throttle_0(event, vjoy):
    if event.is_pressed:
        set_throttle(vjoy, -1.0)

@gremlin.input_devices.keyboard(&quot;2&quot;, &quot;Global&quot;)
def throttle_33(event, vjoy):
    if event.is_pressed:
        set_throttle(vjoy, -0.33)

@gremlin.input_devices.keyboard(&quot;3&quot;, &quot;Global&quot;)
def throttle_66(event, vjoy):
    if event.is_pressed:
        set_throttle(vjoy, 0.33)

@gremlin.input_devices.keyboard(&quot;4&quot;, &quot;Global&quot;)
def throttle_100(event, vjoy):
    if event.is_pressed:
        set_throttle(vjoy, 1.0)</code></pre></figure>


<h3>Joystick Response Curve</h3>

<p class="text-justify">
    This script configures a response curve which provides more control
    around the centre position and uses it for the X and Y axis of the
    joystick.
</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">import gremlin
from gremlin.spline import CubicSpline
from vjoy.vjoy import AxisName

chfs = gremlin.input_devices.JoystickDecorator(
    &quot;CH Fighterstick USB&quot;,
    2382820288,
    &quot;Global&quot;
)

curve = CubicSpline([
    (-1.0, -1.0),
    (-0.5, -0.25),
    ( 0.0,  0.0),
    ( 0.5,  0.25),
    ( 1.0,  1.0)
])

@chfs.axis(1)
def pitch(event, vjoy):
    vjoy[1].axis(AxisName.X).value = curve(event.value)

@chfs.axis(2)
def yaw(event, vjoy):
    vjoy[1].axis(AxisName.Y).value = curve(event.value)</code></pre></figure>


<h3>Mode Switching</h3>

<p class="text-justify">
    This script presents a few different ways of using mode switching
    functionalities. The first callback switches to the <em>Radio</em>
    mode while the button is being held down and switches back to the
    previous mode once the button is released. The next callback cycles
    through the <em>Global</em>, <em>Radio</em>, and <em>Landing</em>
    modes with each button press. The last callback switches directly to
    the <em>Global</em> mode when the button is pressed.
</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">import gremlin

chfs = gremlin.input_devices.JoystickDecorator(
    &quot;CH Fighterstick USB&quot;,
    2382820288,
    &quot;Global&quot;
)

mode_list = gremlin.control_action.ModeList(
        [&quot;Global&quot;, &quot;Radio&quot;, &quot;Landing&quot;]
)

@chfs.button(10)
def temporary_mode_switch(event):
    if event.is_pressed:
        gremlin.control_action.switch_mode(&quot;Radio&quot;)
    else:
        gremlin.control_action.switch_to_previous_mode()

@chfs.button(11)
def cycle_modes(event):
    if event.is_pressed:
        gremlin.control_action.cycle_modes(mode_list)

@chfs.button(12)
def switch_to_global(event):
    if event.is_pressed:
        gremlin.control_action.switch_mode(&quot;Global&quot;)</code></pre></figure>


<h3>Precision Mode</h3>

<p class="text-justify">
    This script switches to a lower sensitivity curve when any of the weapon
    groups are being fired and switches back to the default profile once no
    weapon is being fired any more. This is similar to the "sniper mode"
    that some gaming mice have, which drops the DPI setting at the press of
    a button. In this instance pressing the trigger automatically enables
    and disables this by switching the used response curve to one which
    halves the maximum response provided by the joystick at maximum
    deflection.
</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">import gremlin
from gremlin.spline import CubicSpline
from vjoy.vjoy import AxisName

tm16000 = gremlin.input_devices.JoystickDecorator(
        &quot;Thrustmaster T.16000M&quot;, 1325664945, &quot;Global&quot;
)

default_curve = CubicSpline(
        [(-1.0, -1.0), (0.0, 0.0), (1.0, 1.0)]
)
precision_curve = CubicSpline(
        [(-1.0, -0.5), (0.0, 0.0), (1.0, 0.5)]
)

active_weapon_groups = {}
active_curve = default_curve

def set_weapon_group(gid, is_pressed):
    global active_curve
    global active_weapon_groups
    if is_pressed:
        active_curve = precision_curve
        active_weapon_groups[gid] = True
    else:
        active_weapon_groups[gid] = False
        if sum(active_weapon_groups.values()) == 0:
            active_curve = default_curve

@tm16000.button(1)
def weapon_group_1(event, vjoy):
    set_weapon_group(1, event.is_pressed)
    vjoy[1].button(1).is_pressed = event.is_pressed

@tm16000.button(2)
def weapon_group_2(event, vjoy):
    set_weapon_group(2, event.is_pressed)
    vjoy[1].button(2).is_pressed = event.is_pressed

@tm16000.button(3)
def weapon_group_3(event, vjoy):
    set_weapon_group(3, event.is_pressed)
    vjoy[1].button(3).is_pressed = event.is_pressed

@tm16000.axis(1)
def pitch(event, vjoy):
    vjoy[1].axis(AxisName.X).value = active_curve(event.value)

@tm16000.axis(2)
def yaw(event, vjoy):
    vjoy[1].axis(AxisName.Y).value = active_curve(event.value)</code></pre></figure>

                </div>
                <div class="col-md-2"></div>
            </div>
        </div>


        <footer class="footer">
    <div class="container">
        <div class="col-md-offset-2 col-md8">
            <p class="text-muted">Last update: June 23, 2021</p>
        </div>
    </div>
</footer>


    </body>

</html>
